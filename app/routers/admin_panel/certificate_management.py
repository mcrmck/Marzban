"""
Certificate Management API for Admin Panel

This module provides REST endpoints for automated certificate management:
- Automatic CA generation and management
- Node certificate generation and distribution
- Certificate rotation and lifecycle management
- Docker integration for automated deployment
"""

import os
import logging
import tempfile
from typing import Dict, List, Optional
from pathlib import Path

from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks
from fastapi.responses import FileResponse
from sqlalchemy.orm import Session

from app.db import get_db
from app.models.admin import Admin
from app.services.certificate_manager import CertificateManager, NodeCertificates
from app.utils import responses

logger = logging.getLogger(__name__)

router = APIRouter(tags=["Certificate Management"], responses={401: responses._401})

@router.get("/certificates/ca")
def get_ca_certificate(
    db: Session = Depends(get_db),
    admin: Admin = Depends(Admin.get_current)
):
    """Get the current CA certificate information"""
    cert_manager = CertificateManager(db)
    ca_cert = cert_manager.get_or_create_ca()
    
    return {
        "subject_name": ca_cert.subject_name,
        "issuer_name": ca_cert.issuer_name,
        "serial_number": ca_cert.serial_number,
        "valid_from": ca_cert.valid_from,
        "valid_until": ca_cert.valid_until,
        "is_ca": ca_cert.is_ca,
        "certificate_pem": ca_cert.certificate_pem
    }

@router.post("/certificates/ca/regenerate")
def regenerate_ca_certificate(
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db),
    admin: Admin = Depends(Admin.get_current)
):
    """
    Regenerate the CA certificate
    
    Warning: This will invalidate all existing node certificates
    and require regeneration of all node certificates.
    """
    if not admin.is_sudo:
        raise HTTPException(status_code=403, detail="Only sudo admins can regenerate CA")
    
    cert_manager = CertificateManager(db)
    
    # Force regeneration by creating new CA
    new_ca = cert_manager._generate_ca_certificate()
    
    # Schedule background task to regenerate all node certificates
    background_tasks.add_task(_regenerate_all_node_certificates, db)
    
    logger.warning(f"CA certificate regenerated by admin: {admin.username}")
    
    return {
        "message": "CA certificate regenerated successfully",
        "warning": "All node certificates will be regenerated in the background",
        "ca_info": {
            "subject_name": new_ca.subject_name,
            "valid_from": new_ca.valid_from,
            "valid_until": new_ca.valid_until
        }
    }

@router.post("/certificates/node/{node_name}/generate")
def generate_node_certificates(
    node_name: str,
    node_data: dict,
    db: Session = Depends(get_db),
    admin: Admin = Depends(Admin.get_current)
):
    """
    Generate certificates for a specific node
    
    Args:
        node_name: Unique name for the node
        node_data: Must contain 'address' field with node IP/hostname
    """
    if not node_data.get("address"):
        raise HTTPException(status_code=400, detail="Node address is required")
    
    cert_manager = CertificateManager(db)
    
    try:
        node_certs = cert_manager.generate_node_certificates(
            node_name=node_name,
            node_address=node_data["address"]
        )
        
        logger.info(f"Generated certificates for node: {node_name}")
        
        return {
            "message": f"Certificates generated successfully for node: {node_name}",
            "node_name": node_name,
            "certificates": {
                "ca_cert": {
                    "subject_name": node_certs.ca_cert.subject_name,
                    "valid_until": node_certs.ca_cert.valid_until
                },
                "server_cert": {
                    "subject_name": node_certs.server_cert.subject_name,
                    "valid_until": node_certs.server_cert.valid_until
                },
                "panel_client_cert": {
                    "subject_name": node_certs.panel_client_cert.subject_name,
                    "valid_until": node_certs.panel_client_cert.valid_until
                }
            }
        }
        
    except Exception as e:
        logger.error(f"Failed to generate certificates for node {node_name}: {e}")
        raise HTTPException(status_code=500, detail=f"Certificate generation failed: {str(e)}")

@router.get("/certificates/node/{node_name}")
def get_node_certificates(
    node_name: str,
    db: Session = Depends(get_db),
    admin: Admin = Depends(Admin.get_current)
):
    """Get certificate information for a specific node"""
    cert_manager = CertificateManager(db)
    node_certs = cert_manager.get_node_certificates(node_name)
    
    if not node_certs:
        raise HTTPException(status_code=404, detail=f"No certificates found for node: {node_name}")
    
    return {
        "node_name": node_name,
        "certificates": {
            "ca_cert": {
                "subject_name": node_certs.ca_cert.subject_name,
                "valid_from": node_certs.ca_cert.valid_from,
                "valid_until": node_certs.ca_cert.valid_until
            },
            "server_cert": {
                "subject_name": node_certs.server_cert.subject_name,
                "valid_from": node_certs.server_cert.valid_from,
                "valid_until": node_certs.server_cert.valid_until
            },
            "panel_client_cert": {
                "subject_name": node_certs.panel_client_cert.subject_name,
                "valid_from": node_certs.panel_client_cert.valid_from,
                "valid_until": node_certs.panel_client_cert.valid_until
            }
        }
    }

@router.post("/certificates/node/{node_name}/rotate")
def rotate_node_certificates(
    node_name: str,
    db: Session = Depends(get_db),
    admin: Admin = Depends(Admin.get_current)
):
    """Rotate (regenerate) certificates for a specific node"""
    cert_manager = CertificateManager(db)
    
    try:
        node_certs = cert_manager.rotate_certificates(node_name)
        
        logger.info(f"Rotated certificates for node: {node_name}")
        
        return {
            "message": f"Certificates rotated successfully for node: {node_name}",
            "node_name": node_name,
            "new_certificates": {
                "server_cert": {
                    "subject_name": node_certs.server_cert.subject_name,
                    "valid_until": node_certs.server_cert.valid_until
                },
                "panel_client_cert": {
                    "subject_name": node_certs.panel_client_cert.subject_name,
                    "valid_until": node_certs.panel_client_cert.valid_until
                }
            }
        }
        
    except Exception as e:
        logger.error(f"Failed to rotate certificates for node {node_name}: {e}")
        raise HTTPException(status_code=500, detail=f"Certificate rotation failed: {str(e)}")

@router.get("/certificates/node/{node_name}/export")
def export_node_certificates_for_docker(
    node_name: str,
    db: Session = Depends(get_db),
    admin: Admin = Depends(Admin.get_current)
):
    """
    Export node certificates for Docker deployment
    
    This endpoint exports certificates to the filesystem and returns
    the file paths for Docker volume mounting.
    """
    cert_manager = CertificateManager(db)
    
    try:
        # Export to Docker-compatible directory structure
        export_dir = f"/tmp/marzban-certs/{node_name}"
        file_paths = cert_manager.export_certificates_for_docker(node_name, export_dir)
        
        # Also generate docker-compose volume configuration
        volume_config = _generate_docker_volume_config(node_name, file_paths)
        
        return {
            "message": f"Certificates exported for node: {node_name}",
            "export_directory": export_dir,
            "file_paths": file_paths,
            "docker_volume_config": volume_config,
            "instructions": {
                "step_1": f"Copy files from {export_dir} to your node server",
                "step_2": "Mount the certificates in your node container",
                "step_3": "Use the provided volume configuration in docker-compose"
            }
        }
        
    except Exception as e:
        logger.error(f"Failed to export certificates for node {node_name}: {e}")
        raise HTTPException(status_code=500, detail=f"Certificate export failed: {str(e)}")

@router.get("/certificates/node/{node_name}/download/{cert_type}")
def download_certificate_file(
    node_name: str,
    cert_type: str,
    db: Session = Depends(get_db),
    admin: Admin = Depends(Admin.get_current)
):
    """
    Download individual certificate files
    
    cert_type options: ca_cert, server_cert, server_key, panel_client_cert, panel_client_key
    """
    valid_cert_types = ["ca_cert", "server_cert", "server_key", "panel_client_cert", "panel_client_key"]
    
    if cert_type not in valid_cert_types:
        raise HTTPException(
            status_code=400, 
            detail=f"Invalid cert_type. Must be one of: {', '.join(valid_cert_types)}"
        )
    
    cert_manager = CertificateManager(db)
    node_certs = cert_manager.get_node_certificates(node_name)
    
    if not node_certs:
        raise HTTPException(status_code=404, detail=f"No certificates found for node: {node_name}")
    
    # Create temporary file with the requested certificate
    with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix=f".{cert_type}") as temp_file:
        if cert_type == "ca_cert":
            temp_file.write(node_certs.ca_cert.certificate_pem)
            filename = f"{node_name}-ca.crt"
        elif cert_type == "server_cert":
            temp_file.write(node_certs.server_cert.certificate_pem)
            filename = f"{node_name}-server.crt"
        elif cert_type == "server_key":
            temp_file.write(node_certs.server_cert.private_key_pem)
            filename = f"{node_name}-server.key"
        elif cert_type == "panel_client_cert":
            temp_file.write(node_certs.panel_client_cert.certificate_pem)
            filename = f"{node_name}-panel-client.crt"
        elif cert_type == "panel_client_key":
            temp_file.write(node_certs.panel_client_cert.private_key_pem)
            filename = f"{node_name}-panel-client.key"
        
        temp_file.flush()
        
        return FileResponse(
            path=temp_file.name,
            filename=filename,
            media_type="application/x-pem-file"
        )

@router.get("/certificates/status")
def get_certificate_status(
    db: Session = Depends(get_db),
    admin: Admin = Depends(Admin.get_current)
):
    """Get overall certificate status and expiration information"""
    from app.db.crud import get_expiring_certificates
    
    expiring_certs = get_expiring_certificates(db, days_ahead=30)
    
    return {
        "ca_certificate": {
            "exists": expiring_certs["ca"] is not None,
            "expiring_soon": expiring_certs["ca"] is not None,
            "valid_until": expiring_certs["ca"].valid_until if expiring_certs["ca"] else None
        },
        "node_certificates": {
            "total_nodes": len(expiring_certs["nodes"]),
            "expiring_soon": [
                {
                    "node_name": cert.node_name,
                    "valid_until": cert.valid_until
                }
                for cert in expiring_certs["nodes"]
            ]
        },
        "recommendations": _generate_certificate_recommendations(expiring_certs)
    }

def _regenerate_all_node_certificates(db: Session):
    """Background task to regenerate all node certificates after CA change"""
    from app.db.crud import get_nodes
    
    try:
        cert_manager = CertificateManager(db)
        nodes = get_nodes(db)  # Get all nodes
        
        for node in nodes:
            try:
                cert_manager.generate_node_certificates(node.name, node.address)
                logger.info(f"Regenerated certificates for node: {node.name}")
            except Exception as e:
                logger.error(f"Failed to regenerate certificates for node {node.name}: {e}")
                
    except Exception as e:
        logger.error(f"Failed to regenerate all node certificates: {e}")

def _generate_docker_volume_config(node_name: str, file_paths: Dict[str, str]) -> Dict:
    """Generate Docker volume configuration for the node"""
    return {
        "volumes": [
            f"{file_paths['ca_cert']}:/etc/marzban-node/certs/ca.crt:ro",
            f"{file_paths['server_cert']}:/etc/marzban-node/certs/server.crt:ro",
            f"{file_paths['server_key']}:/etc/marzban-node/certs/server.key:ro"
        ],
        "environment": [
            "SSL_CERT_FILE=/etc/marzban-node/certs/server.crt",
            "SSL_KEY_FILE=/etc/marzban-node/certs/server.key",
            "SSL_CLIENT_CERT_FILE=/etc/marzban-node/certs/ca.crt"
        ],
        "panel_volume_config": [
            f"{file_paths['panel_client_cert']}:/etc/marzban/panel-client-certs/client.crt:ro",
            f"{file_paths['panel_client_key']}:/etc/marzban/panel-client-certs/client.key:ro",
            f"{file_paths['ca_cert']}:/etc/marzban/MyMarzbanCA.pem:ro"
        ]
    }

def _generate_certificate_recommendations(expiring_certs: Dict) -> List[str]:
    """Generate recommendations based on certificate status"""
    recommendations = []
    
    if expiring_certs["ca"]:
        recommendations.append("CA certificate is expiring soon - consider regenerating")
    
    if expiring_certs["nodes"]:
        recommendations.append(f"{len(expiring_certs['nodes'])} node certificates are expiring soon")
    
    if not expiring_certs["ca"] and not expiring_certs["nodes"]:
        recommendations.append("All certificates are healthy")
    
    recommendations.append("Enable automatic certificate rotation for production environments")
    
    return recommendations